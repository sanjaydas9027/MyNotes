# Manual Testing

## 1. Unit Testing
- Unit testing is a key part of the software development life cycle.
- Each single unit or isolated component of a software application is tested individually.
- Focuses on verifying that separate functions, methods, classes, or modules work correctly.
- Ensures individual components are correct before integrating them with other parts of the application.

## 2. Exploratory Testing
- Exploratory testing is a freestyle, intuitive approach to testing.
- No structured test cases are used, so no advance documentation is required.
- The tester explores the software’s functionality and identifies defects on the fly.
- Evaluates performance and usability based on experience, creativity, and intuition.
- Best applied in early development stages or when dealing with complex and rapidly changing applications.

## 3. Smoke Testing
- Also known as “build verification testing.”
- A basic test to check if the software build is stable enough for further testing.
- Covers the most critical functions of the software to ensure they work.
- Conducted early in the development cycle to identify basic critical issues.
- Acts as a gatekeeper to verify core functionalities before integration and system testing.

## 4. Sanity Testing
- A subset of regression testing focused on specific areas after minor changes.
- Checks if particular functionalities are still working after bug fixes or minor updates.
- Ensures that specific functionality works as intended without exhaustive tests.
- Typically conducted towards the end of the development cycle.

## 5. Regression Testing
- Ensures that recent changes do not affect the existing functionality of the product.
- Focuses on identifying unintended consequences of new code.
- Involves retesting existing functionalities after software changes.
- Heavily automated to efficiently check all areas affected by the changes.
- Helps maintain software integrity and delivers a reliable, stable product.

## 6. Acceptance Testing
- Final phase of testing before deployment, validating software against requirements.
- Ensures the software meets business objectives and user requirements.
- Conducted by end-users, clients, or stakeholders rather than developers.
- **Types of Acceptance Testing**:
  - **User Acceptance Testing (UAT):** Performed in an environment that mimics production.
  - **Beta Testing:** Software is released to a limited external audience.

## 7. System Testing
- Examines the complete, integrated software product to ensure it meets requirements.
- Involves both functional and non-functional testing.
- Evaluates the software in an environment close to the production setting.
- Focuses on the entire system’s functionality, performance, security, and compatibility.

## 8. Integration Testing
- Tests interactions between different modules or components.
- Aims to detect inconsistencies in how integrated units interact.
- Uses test drivers and stubs for module integration testing.
- Verifies data communication and functionality between modules.
- Different approaches include big bang, top-down, bottom-up, and sandwich integration.

## 9. User Interface (UI) Testing
- Ensures that the application’s UI functions correctly.
- Can be performed manually by testers or through automation tools.
- Focuses on user experience and interface reliability.

---

## How to Perform Manual Testing?

1. **Requirements**: Understand the software requirements and user stories.
2. **Test Plan**: Define a strategic approach covering testing objectives, resources, schedule, and scope.
3. **Write Test Cases**: Develop test cases for functional and non-functional requirements.
4. **Execute Test Cases**: Run test cases manually and observe the application’s behavior.
5. **Log Defects**: Document any deviations from expected outcomes with details for developers.
6. **Retest and Regression Testing**: Confirm fixes and ensure no new issues have been introduced.
7. **Results Reporting**: Report on testing coverage, defects found, and overall software quality.

## What is the primary goal of manual testing?

- To ensure that the software application functions according to the specified requirements.
- Identify any bugs or issues by manually executing test cases.
- The tester acts as an end-user to assess usability and user experience.

## How does black box testing differ from white box testing?

- **Black Box Testing**:
  - Tester has no knowledge of internal code.
  - Focuses on software functionality and output based on input.
  - Verifies software against specifications and user requirements.

- **White Box Testing**:
  - Requires understanding of internal code and logic.
  - Examines code flow, logic, and execution.
  - Identifies security vulnerabilities and code inefficiencies.

## Why is regression testing important in software development?

- Ensures new changes or enhancements do not affect existing functionality.
- Confirms that existing features work as expected after any modifications.
- Essential in agile environments with frequent changes.

## What is the role of smoke testing in the software development lifecycle?

- Preliminary test to check critical functionalities in a new software build.
- Verifies that the build is stable enough for further testing.
- Identifies major bugs early, saving time and resources.

## Can manual testing be replaced by automated testing?

- While automated testing is efficient for repetitive tasks, manual testing is irreplaceable.
- Essential for areas requiring human judgment, such as usability and exploratory testing.
- A balanced approach with both manual and automated testing is most effective.
# Manual Testing

## Exploratory Testing
- Exploratory testing is a freestyle, intuitive approach to testing.
- No structured test cases are used, so no advance documentation is required.
- The tester explores the software’s functionality and identifies defects on the fly.
- Evaluates performance and usability based on experience, creativity, and intuition.
- Best applied in early development stages or when dealing with complex and rapidly changing applications.

## Smoke Testing
- Also known as “build verification testing.”
- A basic test to check if the software build is stable enough for further testing.
- Covers the most critical functions of the software to ensure they work.
- Conducted early in the development cycle to identify basic critical issues.
- Acts as a gatekeeper to verify core functionalities before integration and system testing.

## Sanity Testing
- A subset of regression testing focused on specific areas after minor changes.
- Checks if particular functionalities are still working after bug fixes or minor updates.
- Ensures that specific functionality works as intended without exhaustive tests.
- Typically conducted towards the end of the development cycle.

## Regression Testing
- Ensures that recent changes do not affect the existing functionality of the product.
- Focuses on identifying unintended consequences of new code.
- Involves retesting existing functionalities after software changes.
- Heavily automated to efficiently check all areas affected by the changes.
- Helps maintain software integrity and delivers a reliable, stable product.

## Acceptance Testing
- Final phase of testing before deployment, validating software against requirements.
- Ensures the software meets business objectives and user requirements.
- Conducted by end-users, clients, or stakeholders rather than developers.
- **Types of Acceptance Testing**:
  - **User Acceptance Testing (UAT):** Performed in an environment that mimics production.
  - **Beta Testing:** Software is released to a limited external audience.

## System Testing
- Examines the complete, integrated software product to ensure it meets requirements.
- Involves both functional and non-functional testing.
- Evaluates the software in an environment close to the production setting.
- Focuses on the entire system’s functionality, performance, security, and compatibility.

## Integration Testing
- Tests interactions between different modules or components.
- Aims to detect inconsistencies in how integrated units interact.
- Uses test drivers and stubs for module integration testing.
- Verifies data communication and functionality between modules.
- Different approaches include big bang, top-down, bottom-up, and sandwich integration.

## User Interface (UI) Testing
- Ensures that the application’s UI functions correctly.
- Can be performed manually by testers or through automation tools.
- Focuses on user experience and interface reliability.

---

## How to Perform Manual Testing?

1. **Requirements**: Understand the software requirements and user stories.
2. **Test Plan**: Define a strategic approach covering testing objectives, resources, schedule, and scope.
3. **Write Test Cases**: Develop test cases for functional and non-functional requirements.
4. **Execute Test Cases**: Run test cases manually and observe the application’s behavior.
5. **Log Defects**: Document any deviations from expected outcomes with details for developers.
6. **Retest and Regression Testing**: Confirm fixes and ensure no new issues have been introduced.
7. **Results Reporting**: Report on testing coverage, defects found, and overall software quality.

## What is the primary goal of manual testing?

- To ensure that the software application functions according to the specified requirements.
- Identify any bugs or issues by manually executing test cases.
- The tester acts as an end-user to assess usability and user experience.

## How does black box testing differ from white box testing?

- **Black Box Testing**:
  - Tester has no knowledge of internal code.
  - Focuses on software functionality and output based on input.
  - Verifies software against specifications and user requirements.

- **White Box Testing**:
  - Requires understanding of internal code and logic.
  - Examines code flow, logic, and execution.
  - Identifies security vulnerabilities and code inefficiencies.

## Why is regression testing important in software development?

- Ensures new changes or enhancements do not affect existing functionality.
- Confirms that existing features work as expected after any modifications.
- Essential in agile environments with frequent changes.

## What is the role of smoke testing in the software development lifecycle?

- Preliminary test to check critical functionalities in a new software build.
- Verifies that the build is stable enough for further testing.
- Identifies major bugs early, saving time and resources.

## Can manual testing be replaced by automated testing?

- While automated testing is efficient for repetitive tasks, manual testing is irreplaceable.
- Essential for areas requiring human judgment, such as usability and exploratory testing.
- A balanced approach with both manual and automated testing is most effective.
